// Copyright 2017 Luan Nico
// Copyright 2023 Toyota Connected North America
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/method_call.h>
#include <flutter/method_channel.h>
#include <flutter/standard_method_codec.h>

#include <map>
#include <optional>
#include <string>

namespace plugin_audio_players {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

/// The codec used by AudioPlayersApi.
const flutter::StandardMethodCodec& AudioPlayersApi::GetCodec() {
  return flutter::StandardMethodCodec::GetInstance();
}

// Sets up an instance of `AudioPlayersApi` to handle messages through the
// `binary_messenger`.
void AudioPlayersApi::SetUp(flutter::BinaryMessenger* binary_messenger,
                            AudioPlayersApi* api) {
  {
    auto channel = std::make_unique<flutter::MethodChannel<>>(
        binary_messenger, "xyz.luan/audioplayers", &GetCodec());
    if (api != nullptr) {
      channel->SetMethodCallHandler(
          [api](const flutter::MethodCall<EncodableValue>& call,
                std::unique_ptr<flutter::MethodResult<EncodableValue>> result) {
            const auto& args = std::get_if<EncodableMap>(call.arguments());

            if ("create" == call.method_name()) {
              for (auto& it : *args) {
                if ("playerId" == std::get<std::string>(it.first) &&
                    std::holds_alternative<std::string>(it.second)) {
                  const auto& player_id_arg = std::get<std::string>(it.second);
                  api->Create(player_id_arg,
                              [result](std::optional<FlutterError>&& output) {
                                if (output.has_value()) {
                                  result->Error("create", "failed",
                                                WrapError(output.value()));
                                  return;
                                }
                                result->Success();
                              });
                  break;
                }
              }
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }

#if 0
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.dispose",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->Dispose(player_id_arg,
                           [reply](std::optional<FlutterError>&& output) {
                             if (output.has_value()) {
                               reply(WrapError(output.value()));
                               return;
                             }
                             EncodableList wrapped;
                             wrapped.push_back(EncodableValue());
                             reply(EncodableValue(std::move(wrapped)));
                           });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger,
        "dev.flutter.pigeon.AudioPlayersApi.getCurrentPosition", &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->GetCurrentPosition(
                  player_id_arg,
                  [reply](ErrorOr<std::optional<int64_t>>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    auto output_optional = std::move(output).TakeValue();
                    if (output_optional) {
                      wrapped.push_back(
                          EncodableValue(std::move(output_optional).value()));
                    } else {
                      wrapped.push_back(EncodableValue());
                    }
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.getDuration",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->GetDuration(
                  player_id_arg,
                  [reply](ErrorOr<std::optional<int64_t>>&& output) {
                    if (output.has_error()) {
                      reply(WrapError(output.error()));
                      return;
                    }
                    EncodableList wrapped;
                    auto output_optional = std::move(output).TakeValue();
                    if (output_optional) {
                      wrapped.push_back(
                          EncodableValue(std::move(output_optional).value()));
                    } else {
                      wrapped.push_back(EncodableValue());
                    }
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.pause",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->Pause(player_id_arg,
                         [reply](std::optional<FlutterError>&& output) {
                           if (output.has_value()) {
                             reply(WrapError(output.value()));
                             return;
                           }
                           EncodableList wrapped;
                           wrapped.push_back(EncodableValue());
                           reply(EncodableValue(std::move(wrapped)));
                         });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.release",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->Release(player_id_arg,
                           [reply](std::optional<FlutterError>&& output) {
                             if (output.has_value()) {
                               reply(WrapError(output.value()));
                               return;
                             }
                             EncodableList wrapped;
                             wrapped.push_back(EncodableValue());
                             reply(EncodableValue(std::move(wrapped)));
                           });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.resume",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->Resume(player_id_arg,
                          [reply](std::optional<FlutterError>&& output) {
                            if (output.has_value()) {
                              reply(WrapError(output.value()));
                              return;
                            }
                            EncodableList wrapped;
                            wrapped.push_back(EncodableValue());
                            reply(EncodableValue(std::move(wrapped)));
                          });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.seek",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_position_arg = args.at(1);
              if (encodable_position_arg.IsNull()) {
                reply(WrapError("position_arg unexpectedly null."));
                return;
              }
              const int64_t position_arg = encodable_position_arg.LongValue();
              api->Seek(player_id_arg, position_arg,
                        [reply](std::optional<FlutterError>&& output) {
                          if (output.has_value()) {
                            reply(WrapError(output.value()));
                            return;
                          }
                          EncodableList wrapped;
                          wrapped.push_back(EncodableValue());
                          reply(EncodableValue(std::move(wrapped)));
                        });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setBalance",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_balance_arg = args.at(1);
              if (encodable_balance_arg.IsNull()) {
                reply(WrapError("balance_arg unexpectedly null."));
                return;
              }
              const auto& balance_arg = std::get<double>(encodable_balance_arg);
              api->SetBalance(player_id_arg, balance_arg,
                              [reply](std::optional<FlutterError>&& output) {
                                if (output.has_value()) {
                                  reply(WrapError(output.value()));
                                  return;
                                }
                                EncodableList wrapped;
                                wrapped.push_back(EncodableValue());
                                reply(EncodableValue(std::move(wrapped)));
                              });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setPlayerMode",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_player_mode_arg = args.at(1);
              if (encodable_player_mode_arg.IsNull()) {
                reply(WrapError("player_mode_arg unexpectedly null."));
                return;
              }
              const auto& player_mode_arg =
                  std::get<std::string>(encodable_player_mode_arg);
              api->SetPlayerMode(player_id_arg, player_mode_arg,
                                 [reply](std::optional<FlutterError>&& output) {
                                   if (output.has_value()) {
                                     reply(WrapError(output.value()));
                                     return;
                                   }
                                   EncodableList wrapped;
                                   wrapped.push_back(EncodableValue());
                                   reply(EncodableValue(std::move(wrapped)));
                                 });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setPlaybackRate",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_playback_rate_arg = args.at(1);
              if (encodable_playback_rate_arg.IsNull()) {
                reply(WrapError("playback_rate_arg unexpectedly null."));
                return;
              }
              const auto& playback_rate_arg =
                  std::get<double>(encodable_playback_rate_arg);
              api->SetPlaybackRate(
                  player_id_arg, playback_rate_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setReleaseMode",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_release_mode_arg = args.at(1);
              if (encodable_release_mode_arg.IsNull()) {
                reply(WrapError("release_mode_arg unexpectedly null."));
                return;
              }
              const auto& release_mode_arg =
                  std::get<std::string>(encodable_release_mode_arg);
              api->SetReleaseMode(
                  player_id_arg, release_mode_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setSourceBytes",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_bytes_arg = args.at(1);
              if (encodable_bytes_arg.IsNull()) {
                reply(WrapError("bytes_arg unexpectedly null."));
                return;
              }
              const auto& bytes_arg =
                  std::get<std::vector<uint8_t>>(encodable_bytes_arg);
              api->SetSourceBytes(
                  player_id_arg, bytes_arg,
                  [reply](std::optional<FlutterError>&& output) {
                    if (output.has_value()) {
                      reply(WrapError(output.value()));
                      return;
                    }
                    EncodableList wrapped;
                    wrapped.push_back(EncodableValue());
                    reply(EncodableValue(std::move(wrapped)));
                  });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setSourceUrl",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_url_arg = args.at(1);
              if (encodable_url_arg.IsNull()) {
                reply(WrapError("url_arg unexpectedly null."));
                return;
              }
              const auto& url_arg = std::get<std::string>(encodable_url_arg);
              const auto& encodable_is_local_arg = args.at(2);
              if (encodable_is_local_arg.IsNull()) {
                reply(WrapError("is_local_arg unexpectedly null."));
                return;
              }
              const auto& is_local_arg = std::get<bool>(encodable_is_local_arg);
              api->SetSourceUrl(player_id_arg, url_arg, is_local_arg,
                                [reply](std::optional<FlutterError>&& output) {
                                  if (output.has_value()) {
                                    reply(WrapError(output.value()));
                                    return;
                                  }
                                  EncodableList wrapped;
                                  wrapped.push_back(EncodableValue());
                                  reply(EncodableValue(std::move(wrapped)));
                                });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.setVolume",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_volume_arg = args.at(1);
              if (encodable_volume_arg.IsNull()) {
                reply(WrapError("volume_arg unexpectedly null."));
                return;
              }
              const auto& volume_arg = std::get<double>(encodable_volume_arg);
              api->SetVolume(player_id_arg, volume_arg,
                             [reply](std::optional<FlutterError>&& output) {
                               if (output.has_value()) {
                                 reply(WrapError(output.value()));
                                 return;
                               }
                               EncodableList wrapped;
                               wrapped.push_back(EncodableValue());
                               reply(EncodableValue(std::move(wrapped)));
                             });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.stop",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              api->Stop(player_id_arg,
                        [reply](std::optional<FlutterError>&& output) {
                          if (output.has_value()) {
                            reply(WrapError(output.value()));
                            return;
                          }
                          EncodableList wrapped;
                          wrapped.push_back(EncodableValue());
                          reply(EncodableValue(std::move(wrapped)));
                        });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.emitLog",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_message_arg = args.at(1);
              if (encodable_message_arg.IsNull()) {
                reply(WrapError("message_arg unexpectedly null."));
                return;
              }
              const auto& message_arg =
                  std::get<std::string>(encodable_message_arg);
              api->EmitLog(player_id_arg, message_arg,
                           [reply](std::optional<FlutterError>&& output) {
                             if (output.has_value()) {
                               reply(WrapError(output.value()));
                               return;
                             }
                             EncodableList wrapped;
                             wrapped.push_back(EncodableValue());
                             reply(EncodableValue(std::move(wrapped)));
                           });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
    } else {
      channel->SetMessageHandler(nullptr);
    }
  }
  {
    auto channel = std::make_unique<BasicMessageChannel<>>(
        binary_messenger, "dev.flutter.pigeon.AudioPlayersApi.emitError",
        &GetCodec());
    if (api != nullptr) {
      channel->SetMessageHandler(
          [api](const EncodableValue& message,
                const flutter::MessageReply<EncodableValue>& reply) {
            try {
              const auto& args = std::get<EncodableList>(message);
              const auto& encodable_player_id_arg = args.at(0);
              if (encodable_player_id_arg.IsNull()) {
                reply(WrapError("player_id_arg unexpectedly null."));
                return;
              }
              const auto& player_id_arg =
                  std::get<std::string>(encodable_player_id_arg);
              const auto& encodable_code_arg = args.at(1);
              if (encodable_code_arg.IsNull()) {
                reply(WrapError("code_arg unexpectedly null."));
                return;
              }
              const auto& code_arg = std::get<std::string>(encodable_code_arg);
              const auto& encodable_message_arg = args.at(2);
              if (encodable_message_arg.IsNull()) {
                reply(WrapError("message_arg unexpectedly null."));
                return;
              }
              const auto& message_arg =
                  std::get<std::string>(encodable_message_arg);
              api->EmitError(player_id_arg, code_arg, message_arg,
                             [reply](std::optional<FlutterError>&& output) {
                               if (output.has_value()) {
                                 reply(WrapError(output.value()));
                                 return;
                               }
                               EncodableList wrapped;
                               wrapped.push_back(EncodableValue());
                               reply(EncodableValue(std::move(wrapped)));
                             });
            } catch (const std::exception& exception) {
              reply(WrapError(exception.what()));
            }
          });
#endif
}
else {
  channel->SetMethodCallHandler(nullptr);
}
}
}

EncodableValue AudioPlayersApi::WrapError(std::string_view error_message) {
  return EncodableValue(
      EncodableList{EncodableValue(std::string(error_message)),
                    EncodableValue("Error"), EncodableValue()});
}

EncodableValue AudioPlayersApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{EncodableValue(error.code()),
                                      EncodableValue(error.message()),
                                      error.details()});
}

}  // namespace plugin_audio_players
